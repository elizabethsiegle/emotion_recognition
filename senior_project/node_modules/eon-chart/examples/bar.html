<html>
  <head>
    <script type="text/javascript" src="../eon-chart.js" ></script>
  </head>
  <body>
    <style type="text/css">
      #chart, #chart2 {
        height: 200px;
      }
    </style>
    <div id="chart"></div>
    <div id="chart2"></div>
    <div id="chart3"></div>
    <script>

      var pubnub = new PubNub({
            publishKey: 'pub-c-923938f1-a4c1-4253-b15a-9c24087904c9',
            subscribeKey: 'sub-c-bd9ab0d6-6e02-11e5-8d3b-0619f8945a4f'
      });

      var channel = "c3-bar-test" + Math.random();

      // --------------- Overrides to get rounded corner is bar charts ------------------
c3.chart.internal.fn.additionalConfig = {
    bar_radiusAll: false,
    bar_radius: 5,
    tooltip_format_color: undefined

};

c3.chart.internal.fn.isOrderDesc = function () {
    var config = this.config;
    if(this.isFunction(config.data_order)) {
        return false;
    }else {
        return config.data_order && config.data_order.toLowerCase() === 'desc';
    }
};

c3.chart.internal.fn.isOrderAsc = function () {
    var config = this.config;
    if(this.isFunction(config.data_order)) {
        return false;
    }else {
        return config.data_order && config.data_order.toLowerCase() === 'asc';
    }
};

c3.chart.internal.fn.generateDrawBar = function (barIndices, isSub) {
    var $$ = this, config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub);
    return function (d, i) {
        // 4 points that make a bar
        var points = getPoints(d, i),
            groups = config.data_groups,
            path = '';

        // switch points if axis is rotated, not applicable for sub chart
        var indexX = config.axis_rotated ? 1 : 0;
        var indexY = config.axis_rotated ? 0 : 1;
        var bar_radius = config.bar_radius;
        var bar_radiusAll = config.bar_radiusAll;
        if(groups && groups.length>0) {
            var lastGrps = [];
            groups.forEach(function(group){
                lastGrps.push(group[group.length-1]);
            });
            //if(points[0][1] < points[1][1] || points[0][0] > points[1][0] ) {
            //  bar_radius = bar_radius*-1;
            //}
            if((points[0][1] === points[1][1]) && (points[1][1]=== points[2][1]) && (points[2][1] === points[3][1]) ||
                (points[0][0] === points[1][0]) && (points[1][0]=== points[2][0]) && (points[2][0] === points[3][0])){
                path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' +
                'L' + points[1][indexX] + ',' + (points[1][indexY]) + ' ' +
                'L' + (points[2][indexX]) + ',' + points[2][indexY] + ' ' +
                'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' +
                'z';
                return path;
            }
            if(lastGrps.indexOf(d.id) > -1 && (config.data_order === null)) {
                if(config.axis_rotated) {
                    path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' +
                    'L' + (points[1][indexX]-bar_radius) + ',' + points[1][indexY] + ' ' +
                    'Q' + points[1][indexX] + ',' + points[1][indexY] + ' ' + points[1][indexX] + ',' + (points[1][indexY]+bar_radius) + ' ' +
                    'L' + points[2][indexX] + ',' + (points[2][indexY]-bar_radius) + ' ' +
                    'Q' + points[2][indexX] + ',' + points[2][indexY] + ' ' + (points[2][indexX]-bar_radius) + ',' + points[2][indexY] + ' ' +
                    'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' +
                    'z';
                }else {
                    path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' +
                    'L' + points[1][indexX] + ',' + (points[1][indexY]+bar_radius) + ' ' +
                    'Q' + points[1][indexX] + ',' + points[1][indexY] + ' ' + (points[1][indexX]+bar_radius) + ',' + points[1][indexY] + ' ' +
                    'L' + (points[2][indexX]-bar_radius) + ',' + points[2][indexY] + ' ' +
                    'Q' + points[2][indexX] + ',' + points[2][indexY] + ' ' + points[2][indexX] + ',' + (points[2][indexY]+bar_radius) + ' ' +
                    'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' +
                    'z';
                }
            }else {
                if(bar_radiusAll) {
                    path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' +
                    'L' + (points[1][indexX]+bar_radius) + ',' + (points[1][indexY]) + ' ' +
                    'Q' + points[1][indexX] + ',' + points[1][indexY] + ' ' + (points[1][indexX]) + ',' + (points[1][indexY]+bar_radius) + ' ' +
                    'L' + (points[2][indexX]) + ',' + (points[2][indexY]-bar_radius) + ' ' +
                    'Q' + points[2][indexX] + ',' + points[2][indexY] + ' ' + (points[2][indexX]+bar_radius) + ',' + (points[2][indexY]) + ' ' +
                    'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' +
                    'z';
                }else {
                    path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' +
                    'L' + points[1][indexX] + ',' + (points[1][indexY]) + ' ' +
                    'L' + (points[2][indexX]) + ',' + points[2][indexY] + ' ' +
                    'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' +
                    'z';
                }
            }
        }else {
            /*path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' +
             'L' + points[1][indexX] + ',' + (points[1][indexY]) + ' ' +
             'L' + (points[2][indexX]) + ',' + points[2][indexY] + ' ' +
             'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' +
             'z';*/
            if(config.axis_rotated) {
                path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' +
                'L' + (points[1][indexX]-bar_radius) + ',' + points[1][indexY] + ' ' +
                'Q' + points[1][indexX] + ',' + points[1][indexY] + ' ' + points[1][indexX] + ',' + (points[1][indexY]+bar_radius) + ' ' +
                'L' + points[2][indexX] + ',' + (points[2][indexY]-bar_radius) + ' ' +
                'Q' + points[2][indexX] + ',' + points[2][indexY] + ' ' + (points[2][indexX]-bar_radius) + ',' + points[2][indexY] + ' ' +
                'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' +
                'z';
            }else {
                path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' +
                'L' + points[1][indexX] + ',' + (points[1][indexY]+bar_radius) + ' ' +
                'Q' + points[1][indexX] + ',' + points[1][indexY] + ' ' + (points[1][indexX]+bar_radius) + ',' + points[1][indexY] + ' ' +
                'L' + (points[2][indexX]-bar_radius) + ',' + points[2][indexY] + ' ' +
                'Q' + points[2][indexX] + ',' + points[2][indexY] + ' ' + points[2][indexX] + ',' + (points[2][indexY]+bar_radius) + ' ' +
                'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' +
                'z';
            }
        }
        return path;
    };
};

      eon.chart({
        pubnub: pubnub,
        channels: [channel],
        limit: 10,
        generate: {
          bindto: '#chart',
          data: {
            labels: true,
            type: 'bar'
          },
          bar: {
            width: {
              ratio: 0.5
            }
          },
          axis: {
              // rotated: true
          }
        }
      });

      eon.chart({
        pubnub: pubnub,
        channels: [channel + '1'],
        xType: 'category',
        generate: {
          bindto: '#chart2',
          data: {
            labels: true,
            type: 'bar'
          },
          bar: {
            width: {
              ratio: 0.5
            }
          },
          axis: {
              rotated: true
          }
        }
      });
    </script>

    <script>
      setInterval(function(){

        pubnub.publish({
          channel: channel,
          message: {
            eon: {
              'Austin': Math.floor(Math.random() * 99),
              'New York': Math.floor(Math.random() * 99),
              'San Francisco': Math.floor(Math.random() * 99),
              'Portland': Math.floor(Math.random() * 99)
            }
          }
        });

      }, 1000);
      setInterval(function(){

        pubnub.publish({
          channel: channel + '1',
          message: {
            eon: {
              'Austin': Math.floor(Math.random() * 99),
              'New York': Math.floor(Math.random() * 99),
              'San Francisco': Math.floor(Math.random() * 99),
              'Portland': Math.floor(Math.random() * 99)
            }
          }
        });

      }, 1000);
    </script>
  </body>
</html>
